<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Calcul Québec: Advanced and Parallel Python</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <img style="height: 50px; margin-top: 20px;" src="img/logo-universite-laval.jpg" />
        <a href="http://www.calculquebec.ca" title="Calcul Québec"><img style="height: 70px; float: right; margin-top: 10px;" src="img/calculquebec_logo_small.jpg" /></a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <a href="index.html"><h1 class="title">Advanced and Parallel Python</h1></a>
          <h2 class="subtitle">Using Multiple Cores</h2>
          <p>The reference Python implementation, CPython, only support the execution of one thread at a time. On modern hardware, we can leverage the power of two, four or even more cores, on one machime, using the multiprocessing module. Be aware that there is also a threading module, which lets you use a shared-memory model, but won’t let you take full advantage of the underlying hardware. See <a href="https://wiki.python.org/moin/GlobalInterpreterLock">GIL description</a> for more information.</p>
<p>When using the multiprocessing module, we use a distributed memory model. That is, a variable, in two different processes, will each have their own values. Communication and synchronisation must then be explicit. As with anything Python, the multiprocessing module makes this simple.</p>
<p>We’ll start back with the first (non-optimized) example for PI approximation:</p>
<pre class="input"><code>$ cp approx_pi.py approx_pi_multiprocessing.py</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> sys
<span class="im">import</span> math
<span class="im">import</span> time

<span class="kw">def</span> approx_pi(intervals):
    pi <span class="op">=</span> <span class="fl">0.0</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(intervals):
        pi <span class="op">+=</span> (<span class="dv">4</span> <span class="op">-</span> <span class="dv">8</span> <span class="op">*</span> (i <span class="op">%</span> <span class="dv">2</span>)) <span class="op">/</span> (<span class="bu">float</span>)(<span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>)
    <span class="cf">return</span> pi

<span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:
    <span class="cf">if</span> <span class="bu">len</span>(sys.argv) <span class="op">!=</span> <span class="dv">2</span>:
        <span class="bu">print</span> <span class="op">&gt;&gt;</span> sys.stderr, <span class="st">&quot;usage: </span><span class="sc">{0}</span><span class="st"> &lt;intervals&gt;&quot;</span>.<span class="bu">format</span>(sys.argv[<span class="dv">0</span>])
        sys.exit(<span class="dv">1</span>)

    t1 <span class="op">=</span> time.clock()
    pi <span class="op">=</span> approx_pi(<span class="bu">int</span>(sys.argv[<span class="dv">1</span>]))
    t2 <span class="op">=</span> time.clock()
    <span class="bu">print</span>(<span class="st">&quot;PI is approximately </span><span class="sc">%.16f</span><span class="st">, Error is </span><span class="sc">%.16f</span><span class="st">&quot;</span><span class="op">%</span>(pi, <span class="bu">abs</span>(pi <span class="op">-</span> math.pi)))
    <span class="bu">print</span>(<span class="st">&quot;Time = </span><span class="sc">%.16f</span><span class="st"> sec</span><span class="ch">\n</span><span class="st">&quot;</span><span class="op">%</span>(t2 <span class="op">-</span> t1))</code></pre></div>
<p>To put this into context, let’s measure the run time again:</p>
<pre class="input"><code>$ python approx_pi_multiprocessing.py 100000000</code></pre>
<pre class="output"><code>PI is approximately 3.1415926435893260, Error is 0.0000000100004671
Time = 34.1915959999999970 sec</code></pre>
<p>When parallelizing, the first thing to decide is how to distribute our data. We want to try and balance the workload fairly amongst all processes. In this case, this is easy as each process will need to loop (about) the same number of time.</p>
<p>Having a look back a our code:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> approx_pi(intervals):
    pi <span class="op">=</span> <span class="fl">0.0</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(intervals):
        pi <span class="op">+=</span> (<span class="dv">4</span> <span class="op">-</span> <span class="dv">8</span> <span class="op">*</span> (i <span class="op">%</span> <span class="dv">2</span>)) <span class="op">/</span> (<span class="bu">float</span>)(<span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>)
    <span class="cf">return</span> pi</code></pre></div>
<p>We take as an input a number of intervals to compute and loop from 0 to intervals-1. One approach could be to accept two parameters: start (inclusive) and end (exclusive). Now our function would look like this:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> approx_pi(start, end):
    pi <span class="op">=</span> <span class="fl">0.0</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(start, end):
        pi <span class="op">+=</span> (<span class="dv">4</span> <span class="op">-</span> <span class="dv">8</span> <span class="op">*</span> (i <span class="op">%</span> <span class="dv">2</span>)) <span class="op">/</span> (<span class="bu">float</span>)(<span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>)
    <span class="cf">return</span> pi</code></pre></div>
<p>This single call will need to be replaced:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    pi <span class="op">=</span> approx_pi(<span class="bu">int</span>(sys.argv[<span class="dv">1</span>]))</code></pre></div>
<p>Now let’s see how we can prepare those intervals. We’ll assume 4 processes for now.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    n <span class="op">=</span> <span class="bu">int</span>(sys.argv[<span class="dv">1</span>])
    chunk_size <span class="op">=</span> n<span class="op">/</span><span class="dv">4</span>
    intervals <span class="op">=</span> <span class="bu">map</span>(<span class="kw">lambda</span> p: [p<span class="op">*</span>chunk_size, p<span class="op">*</span>chunk_size<span class="op">+</span>chunk_size], <span class="bu">range</span>(<span class="dv">4</span>))
    intervals[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>] <span class="op">=</span> <span class="bu">max</span>(intervals[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>], n)</code></pre></div>
<p>The last line is to make sure that if the number of iterations is ot entirely divisible by the number of processes, we do them in the last process instead. If we output those intervals, for 4 processes and 100 million iterations, we get the following:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="bu">print</span> <span class="st">&quot;Intervals: &quot;</span>,intervals</code></pre></div>
<pre class="output"><code>Intervals:  [[0, 25000000], [25000000, 50000000], [50000000, 75000000], [75000000, 100000000]]</code></pre>
<p>Once we have our input data split up correctly, we can try to apply our new function, without any parallelization:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    pi <span class="op">=</span> <span class="bu">sum</span>(<span class="bu">map</span>(approx_pi, intervals))</code></pre></div>
<p>This will apply the approx_pi on each interval, suming the partial sums at the end. This kind of operation is called a reduction and is a fundamental concept in parallel computing. Running it again should yield the right result, in about the same run time as before:</p>
<pre class="input"><code>$ python approx_pi_multiprocessing.py 100000000</code></pre>
<pre class="output"><code>PI is approximately 3.1415926435898172, Error is 0.0000000099999760
Time = 32.7979009999999960 sec</code></pre>
<p>The last missing piece is the actual parallel processing, for which we’ll use the Pool.map parallel implementation of the map algorithm:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">...
<span class="im">from</span> multiprocessing <span class="im">import</span> Pool
...
    p <span class="op">=</span> Pool(<span class="dv">4</span>)
    pi <span class="op">=</span> <span class="bu">sum</span>(p.<span class="bu">map</span>(approx_pi, intervals))</code></pre></div>
<p>And let’s run it:</p>
<pre class="input"><code>$ python approx_pi_multiprocessing.py 100000000</code></pre>
<pre class="output"><code>PI is approximately 3.1415926435898172, Error is 0.0000000099999760
Time = 0.0305790000000000 sec</code></pre>
<p>You’ll notice that the answer is right, the error margin is also good, but that the timing code is way off. It took about 10 seconds to run but we display only 0.03 sec. This is because we use the time.clock function, which is dependent on the current process (start at 0 when the process is launched) and it is confused when starting other processes. Although a little less precise, we’ll change the time.clock function calls to time.time, which doesn’t have this limitation:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    t1 <span class="op">=</span> time.time()
    
    n <span class="op">=</span> <span class="bu">int</span>(sys.argv[<span class="dv">1</span>])
    chunk_size <span class="op">=</span> n<span class="op">/</span><span class="dv">4</span>
    intervals <span class="op">=</span> <span class="bu">map</span>(<span class="kw">lambda</span> p: [p<span class="op">*</span>chunk_size, p<span class="op">*</span>chunk_size<span class="op">+</span>chunk_size], <span class="bu">range</span>(<span class="dv">4</span>))
    intervals[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>] <span class="op">=</span> <span class="bu">max</span>(intervals[<span class="op">-</span><span class="dv">1</span>][<span class="dv">1</span>], n)

    p <span class="op">=</span> Pool(<span class="dv">4</span>)
    pi <span class="op">=</span> <span class="bu">sum</span>(p.<span class="bu">map</span>(approx_pi, intervals))

    t2 <span class="op">=</span> time.time()</code></pre></div>
<p>Which yields the following run tim:</p>
<pre class="input"><code>$ python approx_pi_multiprocessing.py 100000000</code></pre>
<pre class="output"><code>PI is approximately 3.1415926435898172, Error is 0.0000000099999760
Time = 8.9762020111083984 sec</code></pre>
<p>Which is pretty close to a 4 times speedup.</p>
        </div>
      </div>
      </article>
      <div class="footer">
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
  </body>
</html>
