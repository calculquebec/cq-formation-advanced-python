<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Calcul Québec: Advanced and Parallel Python</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <img style="height: 50px; margin-top: 20px;" src="img/logo-universite-laval.jpg" />
        <a href="http://www.calculquebec.ca" title="Calcul Québec"><img style="height: 70px; float: right; margin-top: 10px;" src="img/calculquebec_logo_small.jpg" /></a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <a href="index.html"><h1 class="title">Advanced and Parallel Python</h1></a>
          <h2 class="subtitle">Why (and What) is Python?</h2>
          <h3 id="why-python">Why Python?</h3>
<p>You might wonder why caring about accelerating your (already working) Python code is important. Let’s have a look at a really simple example of PI approximation:</p>
<div class="figure">
<img src="img/pi.png" alt="PI approximation" />
<p class="caption">PI approximation</p>
</div>
<p>We’ll use a naive implementation, both in C and Python for comparison.</p>
<p>Here is relevant part of the C implementation, found in approx_pi.c:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">double</span> approx_pi(<span class="dt">int</span> intervals)
{
     <span class="dt">int</span> i;
     <span class="dt">double</span> pi = <span class="fl">0.0</span>;
     <span class="kw">for</span> (i = <span class="dv">0</span>; i &lt; intervals; i++) {
         pi += (<span class="dv">4</span> - ((i % <span class="dv">2</span>) * <span class="dv">8</span>)) / (<span class="dt">double</span>)(<span class="dv">2</span> * i + <span class="dv">1</span>);
     }
     <span class="kw">return</span> pi;
}</code></pre></div>
<p>And here is the equivalent Python implementation, found in approx_pi.py:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> approx_pi(intervals):
    pi <span class="op">=</span> <span class="fl">0.0</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(intervals):
        pi <span class="op">+=</span> (<span class="dv">4</span> <span class="op">-</span> <span class="dv">8</span> <span class="op">*</span> (i <span class="op">%</span> <span class="dv">2</span>)) <span class="op">/</span> (<span class="bu">float</span>)(<span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>)
    <span class="cf">return</span> pi</code></pre></div>
<p>Compiling and running the resulting binary would result in something like this:</p>
<pre class="input"><code>$ make approx_pi &amp;&amp; ./approx_pi 100000000</code></pre>
<pre class="output"><code>gcc -O2 approx_pi.c -o approx_pi
PI is approximately 3.1415926435893260, Error is 0.0000000100004671
Time = 0.4207670000000000 sec</code></pre>
<p>Be aware that your measurements can be significantly different on different computers. Now for its Python counterpart:</p>
<pre class="input"><code>$ python approx_pi.py 100000000</code></pre>
<pre class="output"><code>PI is approximately 3.1415926435893260, Error is 0.0000000100004671
Time = 34.5257519999999971 sec</code></pre>
<p>You will usually notice that the C version is 80 to 100 times faster than the Python code. You can imagine that when running long simulation, this can make a huge difference.</p>
<h3 id="what-is-python">What is Python?</h3>
<p>Let’s take a step back and answer that question: What is Python?</p>
<p>It is self-described as “Python is a programing language that lets you work quickly and integrate systems more effectively”, which is quite accurate. From a development standpoint, designing, writing and deploying Python code is usually faster than the equivalent C code. As we have seen, the only problem is that you have to make some kind of effort to speed it up.</p>
<p>The first thing to know is that when talking about Python, most people are really talking about <a href="https://python.org">CPython</a>. CPython is the reference implementation of the language but there are others. From the words of its authors, CPython is not always the fastest implementation. Let’s try using one of them, <a href="http://pypy.org/">PyPy</a>, to see how they compare.</p>
<p>Using the same Python code above, we can run it using the PyPy interpreter:</p>
<pre class="input"><code>$ pypy-c ./approx_pi.py 100000000</code></pre>
<pre class="output"><code>PI is approximately 3.1415926435893260, Error is 0.0000000100004671
Time = 0.7333470000000000 sec</code></pre>
<p>That was fast. We are still about twice slower than C, but it’s not bad, taking into account we did not have to change a single line of code. It’s important to note that PyPy has its <a href="http://pypy.org/compat.html">limits</a>:</p>
<ol style="list-style-type: decimal">
<li>It is only Python 2.7.10 compliant, not 3.x (yet).</li>
<li>It supports most of the standard library modules.</li>
<li>It doesn’t support, out of the box, C Python extensions.</li>
<li>Since Numpy is a C extension, they maintain a <a href="https://bitbucket.org/pypy/numpy.git">PyPy-compatible fork</a>.</li>
</ol>
<p>Let’s return to a part the above statement: “integrate systems more effectively”.</p>
<p>Python should really be seen as the glue keeping together multiple components (libraries). And since pure Python is usually pretty slow, compared to C, that means you want to integrate components written in C, and spend most of your computation time inside those libraries, not in your Python code.</p>
<h3 id="numpy">Numpy</h3>
<p>Numpy is a big part of speeding up Python scientific software. Numpy is not the subject of study for this workshop but it is worth mentioning how simple loops can be replaced with Numpy arrays. For example the following equation:</p>
<div class="figure">
<img src="img/sum_numpy.png" alt="Simple Sum" />
<p class="caption">Simple Sum</p>
</div>
<p>Could be reprensented as the following Python code:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> <span class="dv">0</span>.
<span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(N):
    s <span class="op">+=</span> i<span class="op">/</span><span class="dv">10</span>.</code></pre></div>
<p>And could be replaced by this single, very efficient, statement:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">s <span class="op">=</span> numpy.<span class="bu">sum</span>(numpy.arange(N)<span class="op">/</span><span class="dv">10</span>.)</code></pre></div>
<section class="challenge panel panel-success">
<div class="panel-heading">
<h2 id="using-numpy"><span class="glyphicon glyphicon-pencil"></span>Using Numpy</h2>
</div>
<div class="panel-body">
<p>Use Numpy’s <em>arange</em> function to speed up the following code:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> approx_pi(intervals):
    pi <span class="op">=</span> <span class="fl">0.0</span>
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(intervals):
        pi <span class="op">+=</span> (<span class="dv">4</span> <span class="op">-</span> <span class="dv">8</span> <span class="op">*</span> (i <span class="op">%</span> <span class="dv">2</span>)) <span class="op">/</span> (<span class="bu">float</span>)(<span class="dv">2</span> <span class="op">*</span> i <span class="op">+</span> <span class="dv">1</span>)
    <span class="cf">return</span> pi</code></pre></div>
<p>The solution can be found in the solutions/approx_pi_numpy.py file.</p>
</div>
</section>
<p>Running the solution for the previous challenge would yield this result:</p>
<pre class="input"><code>$ python approx_pi_numpy.py 100000000</code></pre>
<pre class="output"><code>PI is approximately 3.1415926435844881, Error is 0.0000000100053050
Time = 1.2332240000000001 sec</code></pre>
<p>While not as good as with the PyPy interpreter, it’s still quite an improvement compared to our original version. The advantage of using Numpy is that you maintain full compatibility with the official Python release. This is something you want to take into account when deciding whether you should use the PyPy interpreter. It all depends on the libraries you are using and the level of compatibility vs. performance you want to achieve.</p>
        </div>
      </div>
      </article>
      <div class="footer">
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
  </body>
</html>
